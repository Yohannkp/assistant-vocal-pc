"""
Assistant Vocal PC avec Ollama Mistral
=====================================

D√©pendances requises:
- speech_recognition : pour la reconnaissance vocale
- pyttsx3 : pour la synth√®se vocale (text-to-speech)
- pyaudio : pour l'audio (microphone)
- requests : pour les appels API
- pygame : alternative pour l'audio si n√©cessaire

Installation:
pip install speech_recognition pyttsx3 pyaudio requests pygame
"""

import speech_recognition as sr
import pyttsx3
import requests
import json
import threading
import time
import sys
import os
import subprocess
from datetime import datetime

# Import Coqui TTS avec gestion d'erreur
try:
    from TTS.api import TTS
    COQUI_AVAILABLE = True
except ImportError:
    COQUI_AVAILABLE = False

class AssistantVocal:
    def __init__(self):
        # Configuration Ollama
        self.ollama_url = "http://127.0.0.1:11434"
        self.model_name = "mistral:instruct"
        
        # Configuration de la reconnaissance vocale
        self.recognizer = sr.Recognizer()
        self.microphone = sr.Microphone()
        
        # Configuration optimis√©e pour √©viter les coupures de parole
        self.recognizer.energy_threshold = 4000  # Seuil d'√©nergie plus √©lev√©
        self.recognizer.dynamic_energy_threshold = True  # Ajustement automatique
        self.recognizer.pause_threshold = 1.5  # Attendre 1.5 secondes de silence avant de s'arr√™ter
        self.recognizer.phrase_time_limit = None  # Pas de limite de temps pour une phrase
        self.recognizer.non_speaking_duration = 0.8  # Dur√©e de silence pour consid√©rer que la phrase est finie
        
        # Configuration de la synth√®se vocale
        self.tts_engine = pyttsx3.init()
        self.setup_tts()
        
        # Configuration Coqui TTS (voix naturelle)
        self.coqui_engine = None
        self.current_tts_method = "auto"  # auto, coqui, sapi
        self.setup_coqui_tts()
        
        # √âtat de l'assistant
        self.listening = False
        self.active = True
        
        print("ü§ñ Assistant Vocal initialis√©")
        self.speak("Bonjour ! Je suis votre assistant vocal. Dites 'Assistant' pour me r√©veiller.")
    
    def setup_tts(self):
        """Configure les param√®tres de synth√®se vocale avec gestion robuste"""
        try:
            # Test de l'engine principal
            if self.tts_engine:
                voices = self.tts_engine.getProperty('voices')
                
                # Afficher toutes les voix disponibles pour debug
                print("üó£Ô∏è  Voix disponibles:")
                french_voice_found = False
                
                if voices:
                    for i, voice in enumerate(voices):
                        if voice:
                            print(f"   {i}: {voice.name}")
                            # Chercher une voix fran√ßaise (priorit√© √† Hortense)
                            if 'hortense' in voice.name.lower():
                                self.tts_engine.setProperty('voice', voice.id)
                                print(f"‚úÖ Voix fran√ßaise s√©lectionn√©e: {voice.name}")
                                french_voice_found = True
                                break
                            elif 'french' in voice.name.lower() or 'fr' in voice.id.lower():
                                self.tts_engine.setProperty('voice', voice.id)
                                print(f"‚úÖ Voix fran√ßaise s√©lectionn√©e: {voice.name}")
                                french_voice_found = True
                                # Continue pour chercher Hortense si possible
                
                if not french_voice_found:
                    print("‚ö†Ô∏è  Aucune voix fran√ßaise trouv√©e, utilisation de la voix par d√©faut")
                
                # Configuration optimis√©e
                self.tts_engine.setProperty('rate', 160)  # Vitesse claire
                self.tts_engine.setProperty('volume', 1.0)  # Volume maximum
                
                print("‚úÖ Synth√®se vocale configur√©e")
            else:
                print("‚ùå Moteur TTS non initialis√©")
                
        except Exception as e:
            print(f"‚ùå Erreur configuration TTS: {e}")
            print("üîß L'assistant utilisera des m√©thodes de fallback")
    
    def setup_coqui_tts(self):
        """Configure Coqui TTS pour des voix naturelles"""
        if not COQUI_AVAILABLE:
            print("‚ö†Ô∏è Coqui TTS non disponible - utilisation de Windows SAPI")
            self.current_tts_method = "sapi"
            return
        
        try:
            print("üé§ Initialisation Coqui TTS...")
            # Utiliser le mod√®le anglais qui fonctionne bien
            self.coqui_engine = TTS(
                model_name="tts_models/en/ljspeech/tacotron2-DDC", 
                progress_bar=False, 
                gpu=False
            )
            # Utiliser SAPI par d√©faut car plus stable
            self.current_tts_method = "sapi"
            print("‚úÖ Coqui TTS disponible en option - Voix SAPI fran√ßaise par d√©faut")
            
        except Exception as e:
            print(f"‚ö†Ô∏è Coqui TTS non disponible: {e}")
            print("üîß Utilisation de Windows SAPI")
            self.current_tts_method = "sapi"
    
    def speak(self, text):
        """Synth√®se vocale intelligente - Coqui TTS puis SAPI"""
        if not text or not text.strip():
            return False
        
        print(f"üîä Assistant: {text}")
        
        # M√©thode 1: Coqui TTS (voix naturelle)
        if self.current_tts_method in ["auto", "coqui"] and self.coqui_engine:
            if self.speak_coqui(text):
                return True
            else:
                print("üîÑ Basculement vers SAPI...")
                self.current_tts_method = "sapi"
        
        # M√©thode 2: Windows SAPI (fallback)
        return self.speak_sapi(text)
    
    def speak_coqui(self, text):
        """Synth√®se avec Coqui TTS (voix naturelle)"""
        try:
            # Fichier temporaire
            output_file = "temp_coqui_tts.wav"
            
            # G√©n√©rer l'audio avec Coqui
            start_time = time.time()
            self.coqui_engine.tts_to_file(text=text, file_path=output_file)
            duration = time.time() - start_time
            
            # Lire avec PowerShell (plus stable)
            result = subprocess.run(
                ['powershell', '-Command', f"(New-Object Media.SoundPlayer '{output_file}').PlaySync()"],
                capture_output=True,
                text=True,
                timeout=15  # Timeout √©tendu √† 15 secondes
            )
            
            # Nettoyer
            try:
                os.remove(output_file)
            except:
                pass
            
            if result.returncode == 0:
                print(f"‚úÖ Coqui TTS r√©ussi ({duration:.2f}s)")
                return True
            else:
                print(f"‚ö†Ô∏è Erreur lecture audio: {result.returncode}")
                return False
                
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur Coqui TTS: {e}")
            return False
    
    def speak_sapi(self, text):
        """Synth√®se avec Windows SAPI (voix fran√ßaise optimis√©e)"""
        try:
            # Nettoyer le texte pour PowerShell - √©liminer tous les caract√®res probl√©matiques
            safe_text = text.replace('"', "").replace("'", "").replace('\\', '').replace('`', '')
            safe_text = safe_text.replace('\n', ' ').replace('\r', ' ')
            safe_text = safe_text.replace(':', ' ').replace(';', ' ')
            
            # Limiter la longueur
            if len(safe_text) > 400:
                safe_text = safe_text[:397] + "..."
            
            # Commande PowerShell SAPI simplifi√©e et robuste
            cmd = f'powershell -Command "Add-Type -AssemblyName System.Speech; $s = New-Object System.Speech.Synthesis.SpeechSynthesizer; $s.SetOutputToDefaultAudioDevice(); $s.Rate = 1; $s.Volume = 100; $s.Speak(\\"{safe_text}\\"); $s.Dispose()"'
            
            start_time = time.time()
            result = os.system(cmd)
            duration = time.time() - start_time
            
            if result == 0:
                print(f"‚úÖ SAPI r√©ussi ({duration:.2f}s)")
                return True
            else:
                print(f"‚ùå Erreur SAPI: {result}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erreur SAPI: {e}")
            return False
    
    def listen_for_wake_word(self):
        """√âcoute le mot de r√©veil 'Assistant'"""
        print("üëÇ En attente du mot de r√©veil 'Assistant'...")
        
        with self.microphone as source:
            print("üîß Calibration du microphone pour le bruit ambiant...")
            self.recognizer.adjust_for_ambient_noise(source, duration=2)
            print(f"‚úÖ Seuil d'√©nergie ajust√© √†: {self.recognizer.energy_threshold}")
        
        while self.active:
            try:
                with self.microphone as source:
                    # √âcoute passive pour le mot de r√©veil avec timeout plus court
                    audio = self.recognizer.listen(source, timeout=1, phrase_time_limit=4)
                
                try:
                    text = self.recognizer.recognize_google(audio, language='fr-FR').lower()
                    print(f"üé§ D√©tect√©: {text}")
                    
                    if 'assistant' in text:
                        self.speak("Pr√©sent ! Je vous √©coute.")
                        # Entrer en mode conversation continue
                        self.conversation_mode()
                
                except sr.UnknownValueError:
                    pass  # Rien compris, continuer l'√©coute
                
            except sr.WaitTimeoutError:
                pass  # Timeout normal, continuer
            except Exception as e:
                print(f"‚ùå Erreur d'√©coute: {e}")
                time.sleep(1)
    
    def conversation_mode(self):
        """Mode conversation continue apr√®s le mot de r√©veil"""
        print("üí¨ Mode conversation activ√© - Parlez naturellement ou dites 'fini' pour arr√™ter")
        print("‚è±Ô∏è  Configuration: Pause de 1.5s avant traitement, pas de limite de temps")
        
        while self.active:
            try:
                with self.microphone as source:
                    print("üé§ Parlez maintenant... (Prenez votre temps, je vous laisse finir)")
                    # Param√®tres optimis√©s pour laisser le temps de parler
                    audio = self.recognizer.listen(
                        source, 
                        timeout=15,  # Timeout plus long pour commencer √† parler
                        phrase_time_limit=30  # Limite de 30 secondes pour une phrase compl√®te
                    )
                
                try:
                    print("üîÑ Traitement de votre parole... (cela peut prendre quelques secondes)")
                    command = self.recognizer.recognize_google(audio, language='fr-FR')
                    print(f"üé§ Commande re√ßue: {command}")
                    
                    # V√©rifier les commandes de sortie de conversation
                    command_lower = command.lower()
                    if any(word in command_lower for word in ['fini', 'termin√©', 'stop conversation', 'pause']):
                        self.speak("Conversation termin√©e. Redites 'Assistant' pour me r√©veiller.")
                        print("üëÇ Retour au mode d'√©coute du mot de r√©veil...")
                        break
                    
                    # FEEDBACK : Confirmer qu'on a compris et qu'on commence
                    self.speak(f"Compris ! Je traite votre demande : {command}")
                    
                    # Traiter la commande
                    self.process_command(command)
                    
                    # Si l'assistant doit s'arr√™ter compl√®tement, sortir
                    if not self.active:
                        break
                    
                    # Confirmer que la t√¢che est termin√©e
                    self.speak("T√¢che termin√©e ! Que puis-je faire d'autre pour vous ?")
                    print("üí¨ Continuez la conversation ou dites 'fini'...")
                    
                except sr.UnknownValueError:
                    print("‚ùå Parole non comprise")
                    self.speak("D√©sol√©, je n'ai pas compris votre parole. Pouvez-vous r√©p√©ter plus clairement ?")
                except sr.RequestError as e:
                    print(f"‚ùå Erreur de reconnaissance: {e}")
                    self.speak(f"Erreur de reconnaissance vocale d√©tect√©e : {str(e)}. Veuillez r√©essayer.")
                    
            except sr.WaitTimeoutError:
                print("‚è∞ Timeout - retour au mode d'√©coute")
                self.speak("Je n'ai rien entendu pendant 15 secondes. Je retourne en mode veille. Redites 'Assistant' pour me r√©veiller.")
                break
    
    def listen_for_command(self):
        """√âcoute une commande apr√®s le mot de r√©veil"""
        print("üëÇ En attente de votre commande...")
        
        try:
            with self.microphone as source:
                # √âcoute active pour la commande avec plus de patience
                print("üé§ Parlez maintenant... (Prenez votre temps)")
                audio = self.recognizer.listen(
                    source, 
                    timeout=12,  # Plus de temps pour commencer
                    phrase_time_limit=25  # Plus de temps pour finir
                )
            
            try:
                print("üîÑ Traitement de votre parole...")
                command = self.recognizer.recognize_google(audio, language='fr-FR')
                print(f"üé§ Commande re√ßue: {command}")
                
                # FEEDBACK IMPORTANT : Confirmer qu'on a compris
                self.speak(f"J'ai compris: {command}. Je traite votre demande.")
                
                # Traiter la commande
                self.process_command(command)
                
            except sr.UnknownValueError:
                print("‚ùå Parole non comprise")
                self.speak("D√©sol√©, je n'ai pas compris votre demande. Pouvez-vous r√©p√©ter plus clairement ?")
            except sr.RequestError as e:
                print(f"‚ùå Erreur de reconnaissance: {e}")
                self.speak("Erreur de reconnaissance vocale. Veuillez r√©essayer.")
                
        except sr.WaitTimeoutError:
            print("‚è∞ Timeout - rien entendu")
            self.speak("Je n'ai rien entendu. Redites 'Assistant' pour me r√©veiller.")
    
    def process_command(self, command):
        """Traite une commande vocale avec feedback d√©taill√©"""
        command_lower = command.lower()
        
        # Commandes sp√©ciales de fermeture compl√®te
        if any(word in command_lower for word in ['arr√™t', 'stop', 'au revoir', 'fermer', 'arr√™te toi']):
            self.speak("Commande d'arr√™t re√ßue. Au revoir ! √Ä bient√¥t.")
            self.active = False
            return
        
        if any(word in command_lower for word in ['silence', 'tais-toi', 'chut']):
            self.speak("Commande de silence re√ßue. D'accord, je me tais.")
            return
        
        if any(word in command_lower for word in ['test voix', 'test audio']):
            self.speak("Test de la synth√®se vocale en cours.")
            time.sleep(0.5)
            if self.current_tts_method == "coqui":
                self.speak("Vous entendez actuellement la voix naturelle Coqui TTS. Elle sonne beaucoup plus naturelle que les voix Windows.")
            else:
                self.speak("Vous entendez actuellement la voix Windows SAPI. Dites 'voix naturelle' pour utiliser Coqui TTS.")
            return
        
        if any(word in command_lower for word in ['voix naturelle', 'coqui', 'meilleure voix']):
            if COQUI_AVAILABLE and self.coqui_engine:
                self.current_tts_method = "coqui"
                self.speak("Basculement vers la voix naturelle Coqui TTS. Cette voix est beaucoup plus agr√©able √† √©couter.")
            else:
                self.speak("La voix naturelle Coqui TTS n'est pas disponible. Installation n√©cessaire.")
            return
        
        if any(word in command_lower for word in ['voix windows', 'voix classique', 'sapi']):
            self.current_tts_method = "sapi"
            self.speak("Basculement vers la voix Windows SAPI classique.")
            return
        
        # Commandes syst√®me avec feedback d√©taill√©
        if any(word in command_lower for word in ['d√©marre chrome', 'ouvre chrome', 'lance chrome']):
            self.speak("D√©sol√©, je ne peux pas d√©marrer des applications syst√®me pour des raisons de s√©curit√©. Mais je peux vous aider avec d'autres questions.")
            return
        
        if any(word in command_lower for word in ['ouvre', 'lance', 'd√©marre']):
            self.speak("Je ne peux pas lancer d'applications, mais je peux vous donner des informations ou r√©pondre √† vos questions.")
            return
        
        # Envoi √† Mistral avec feedback complet
        self.speak("Connexion √† Mistral en cours. Je traite votre demande...")
        
        try:
            response = self.query_mistral(command)
            
            if response and response.strip():
                print(f"üìù R√©ponse Mistral: {response}")
                self.speak("R√©ponse re√ßue de Mistral avec succ√®s.")
                time.sleep(0.3)
                self.speak(response)
                self.speak("Traitement termin√© avec succ√®s !")
            else:
                error_msg = "Mistral n'a pas pu g√©n√©rer de r√©ponse. Cela peut √™tre d√ª √† un probl√®me de connexion ou de compr√©hension de la demande."
                print(f"‚ùå {error_msg}")
                self.speak(error_msg)
                
        except Exception as e:
            error_details = str(e)
            error_msg = f"Erreur technique d√©tect√©e : {error_details}"
            print(f"‚ùå {error_msg}")
            self.speak(f"Une erreur technique s'est produite. D√©tails : {error_details}")
            self.speak("Veuillez r√©essayer votre demande.")
    
    def query_mistral(self, prompt):
        """Envoie une requ√™te √† l'API Ollama Mistral avec feedback d√©taill√©"""
        url = f"{self.ollama_url}/api/generate"
        
        payload = {
            "model": self.model_name,
            "prompt": f"R√©ponds en fran√ßais de mani√®re concise et naturelle √† cette question ou demande : {prompt}",
            "stream": False
        }
        
        try:
            print(f"ü§ñ Envoi √† Mistral: {prompt}")
            start_time = time.time()
            
            response = requests.post(url, json=payload, timeout=30)
            response.raise_for_status()
            
            end_time = time.time()
            duration = end_time - start_time
            
            result = response.json()
            response_text = result.get('response', '').strip()
            
            # Feedback de succ√®s avec d√©tails
            print(f"‚úÖ R√©ponse re√ßue en {duration:.2f}s")
            if result.get('eval_count'):
                print(f"üìä {result.get('eval_count')} tokens g√©n√©r√©s")
            
            return response_text
            
        except requests.exceptions.Timeout:
            error_msg = "Timeout : Mistral met trop de temps √† r√©pondre"
            print(f"‚ùå {error_msg}")
            raise Exception(error_msg)
        except requests.exceptions.ConnectionError:
            error_msg = "Erreur de connexion : Impossible de joindre Ollama. V√©rifiez que le serveur est d√©marr√©"
            print(f"‚ùå {error_msg}")
            raise Exception(error_msg)
        except requests.exceptions.RequestException as e:
            error_msg = f"Erreur API Ollama : {str(e)}"
            print(f"‚ùå {error_msg}")
            raise Exception(error_msg)
    
    def test_components(self):
        """Teste les composants de l'assistant"""
        print("üß™ Test des composants...")
        
        # Test TTS avec feedback d√©taill√©
        print("üîä Test de la synth√®se vocale...")
        test_phrase = "Test de la synth√®se vocale. Vous devez entendre cette phrase √† voix haute."
        self.speak(test_phrase)
        
        # Demander confirmation √† l'utilisateur
        audio_ok = input("Avez-vous entendu la synth√®se vocale ? (o/n): ").lower()
        if audio_ok not in ['o', 'oui', 'y', 'yes']:
            print("‚ö†Ô∏è  Probl√®me audio d√©tect√© - v√©rifiez vos haut-parleurs")
        
        # Test microphone
        print("üé§ Test du microphone - dites 'test microphone'...")
        try:
            with self.microphone as source:
                print("üîß Ajustement du bruit ambiant...")
                self.recognizer.adjust_for_ambient_noise(source, duration=2)
                print("üëÇ En √©coute... (vous avez 8 secondes, prenez votre temps)")
                audio = self.recognizer.listen(source, timeout=8, phrase_time_limit=20)
                
            print("üîÑ Traitement de l'audio...")
            text = self.recognizer.recognize_google(audio, language='fr-FR')
            print(f"‚úÖ Microphone OK - D√©tect√©: {text}")
            self.speak(f"Parfait ! J'ai bien entendu: {text}")
            
        except sr.WaitTimeoutError:
            print("‚è∞ Rien entendu dans les 8 secondes")
            self.speak("Je n'ai rien entendu. V√©rifiez votre microphone.")
        except Exception as e:
            print(f"‚ùå Erreur microphone: {e}")
            self.speak("Erreur de microphone d√©tect√©e.")
        
        # Test API Mistral
        print("ü§ñ Test de l'API Mistral...")
        response = self.query_mistral("R√©ponds simplement 'Test API r√©ussi'")
        if response:
            print(f"‚úÖ API Mistral OK - R√©ponse: {response}")
            self.speak(f"Excellent ! Mistral r√©pond: {response}")
        else:
            print("‚ùå Erreur API Mistral")
            self.speak("Probl√®me de connexion avec Mistral.")
        
        print("\nüéØ Tests termin√©s. L'assistant est pr√™t !")
    
    def run(self):
        """Lance l'assistant vocal"""
        print("üöÄ D√©marrage de l'assistant vocal...")
        print("üí° Dites 'Assistant' pour me r√©veiller")
        print("üí° Une fois en conversation, parlez naturellement")
        print("üí° Dites 'fini' pour revenir au mode veille")
        print("üí° Dites 'au revoir' pour m'arr√™ter compl√®tement")
        print("-" * 50)
        
        try:
            self.listen_for_wake_word()
        except KeyboardInterrupt:
            print("\nüëã Arr√™t de l'assistant...")
            self.active = False
            self.speak("Au revoir !")

def main():
    print("ü§ñ Assistant Vocal PC avec Ollama Mistral")
    print("=" * 50)
    
    try:
        assistant = AssistantVocal()
        
        # Demander si on veut faire des tests
        choice = input("\nVoulez-vous tester les composants d'abord ? (o/n): ").lower()
        if choice in ['o', 'oui', 'y', 'yes']:
            assistant.test_components()
            input("\nAppuyez sur Entr√©e pour continuer...")
        
        # Lancer l'assistant
        assistant.run()
        
    except Exception as e:
        print(f"‚ùå Erreur fatale: {e}")

if __name__ == "__main__":
    main()
